#### 第一章
##### 1.1
  1、数据结构：计算机组织和存储数据的方式，以及定义该数据上的一组操作
 
  2、解决问题的步骤
   
    1. 建立数学模型
    2. 设计算法
    3. 编程实现算法

  3、数据结构

    1. 逻辑结构
    2. 存储结构
    3. 基本运算

  4、数据：符号的集合
    数据元素：数据的基本单位
    数据项：数据最小单位，字段/域
    原始数据：实际问题中的数据
  
  5、逻辑结构：数据元素之间的结构关系
    
    1. 集合
    2. 线性结构
    3. 树状结构
    4. 图状结构

  6、物理结构/存储结构：数据的逻辑结构在计算机中的实现
    数据结构的存储 = 数据元素的存储 + 元素逻辑关系的存储

    1. 顺序存储
    2. 链式存储
    3. 索引存储
    4. 散列存储
  
##### 1.2
  1、顺序结构：将元素存储到一片连续的存储区
    特点：

      1. 需要预估长度
      2. 插入和删除都需要移动其他数据
      3. 存取快捷，是随机存取结构

  2、链式结构：借助元素地址的指针表示数据的逻辑结构
    结点的存储单元：数据项+指针项
    特点：

      1. 动态分配，不需要预估长度
      2. 插入和删除不需要移动其他数据
      3. 非随机存储

  3、索引结构

  4、散列结构

##### 1.3 算法及描述

  1、算法特性：
    
    1. 有穷性 
    2. 确定性
    3. 可行性
    4. 输入
    5. 输出
  
  2、算法设计应该满：

    1. 正确性
    2. 易读性
    3. 健壮性：错误提示处理
    4. 时空性

  3、时间复杂度：算法运行总步数
    1. 最坏请看时间复杂度
    2. 平均时间复杂度

    排序：
    常数 O(1)
    对数 O(log2n)
    线性 O(n)
    线性对数 O(nlog2n)
    平方 O(n^2)
    多项式阶 O(n^c)
    指数 O(C^n)
    
  4、空间复杂度：算法执行所占用的存储空间
    代码占用空间
    输入数据占用空间
    辅助变量占用空间
  

#### 第二章 线性表
  L(a1,a2,a3,....a,n)
  直接前驱
  直接后继

  * 2.1 线性表的顺序存储（顺序表）
    一组连续的存储单元
  * 2.2 线性表顺序表的基本运算
    1. 插入
      移动 n-i+1 个数据
      最好情况 0
      最坏情况 n
      平均移动次数 n/2
      时间复杂度 O(n)

    2. 删除
      移动 n-i 个数据
      最好情况 0
      最坏情况 n-1
      平均移动次数 (n-1)/2
      时间复杂度 O(n)

    3. 定位
      最好情况 1
      最坏情况 n
      平均查找长度： (n+1)/2 
      时间复杂度 O(n)
      求表长和读表元素的时间复杂度O(1)

  * 2.3 线性表的链接存储（链表）
    一组任意的存储单元
    数据项 + 指针项
    
  * 2.3.1 单链表
    头结点 Head  不属于表结点
    首结点       没有直接前驱
    尾结点 Null  没有直接后继

    1. 初始化

      ```
        typedef struct node{
          DataType data;
          struct node*next;
        }Node,*LinkList;
      
        LinkList InitiateLinkList()
        {
          LinkList head; //头指针
          head = malloc(sizeof(Node)); 
          head->next = NULL; //头结点指向NULL
          return head;
        }

      ```
    2. 求表长
      时间复杂度 O(n)


      ```
      int lengthLinkList(LinkList head)
      {
        Node *p;
        p=head;j=0;
        while(p->next!=NULL)
        {
          p=p->next
          j++;
        }
        return j;
      }

      ```
    
    3. 读取元素
      时间复杂度 O(n)

    4. 删除结点
      删除p结点：p->prev->next = p->next

    5. 插入结点
      先挂上：p->next = q->next;
      再剪断：q->next = p;

  * 2.1 
  * 2.1 























  * 2.1 






  